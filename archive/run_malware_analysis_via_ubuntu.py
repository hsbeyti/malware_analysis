import traceback
from vboxapi import VirtualBoxManager
import time

def main():
    print("Initializing VirtualBoxManager...")
    mgr = VirtualBoxManager(None, None)
    guest_session_ubuntu = None
    process = None  # Track the process object

    try:
        # Initialize VirtualBox
        vbox = mgr.getVirtualBox()
        session = mgr.getSessionObject(vbox)
        print("VirtualBox initialized successfully.")

        # Locate the Ubuntu machine
        try:
            ubuntu_machine = vbox.findMachine("ftpserver")
            print("Machine located: ftpserver.")
        except Exception as e:
            print(f"Error locating machine 'ftpserver': {e}")
            return

        # Lock the machine
        try:
            ubuntu_machine.lockMachine(session, mgr.constants.LockType_Shared)
            console = session.console
            print("Machine locked and console acquired.")
        except Exception as e:
            print(f"Error locking the machine: {e}")
            return

        # Create a guest session
        try:
            guest_session_ubuntu = console.guest.createSession("hsbeyti", "phd@2005AOU!", "", "")
            print("Guest session created successfully.")
            time.sleep(2)
        except Exception as e:
            print(f"Error creating guest session: {e}")
            return

        # Process creation
        print("Starting process creation for test.sh script...")
        argument = "/home/hsbeyti/run_on_windows_via_ssh.sh"
        command_to_run = "ping"
        command_time_out = "test.sh"
        flags = [
            mgr.constants.ProcessCreateFlag_WaitForStdOut,
            mgr.constants.ProcessCreateFlag_WaitForStdErr,
        ]
        try:
            print("Attempting to create process...")
            process = guest_session_ubuntu.processCreateEx(
                "/bin/bash",  # Use bash to execute shell scripts
                ["bash", argument, command_to_run,command_time_out],  # Pass the script to be executed
                "",  # Current working directory
                [],  # Environment variables
                flags,  # Flags
                120000,  # Timeout in ms
                0,  # Normal priority
                [],  # CPU affinity
            )
            print("Process created successfully.")

        except Exception as e:
            print(f"Error occurred during process creation: {e}")
            traceback.print_exc()

        # Wait for the process to start and then monitor its status until it ends
        try:
            # Wait for the process to start
            print("Waiting for process to start...")
            while process.status == mgr.constants.ProcessStatus_Starting:
                time.sleep(2)

            process_id = process.PID  # Access PID after the process has started
            print(f"Process ID (PID): {process_id}")

            # Now we monitor the process status until it ends
            print("Monitoring process status...")

            while process.status not in [
                mgr.constants.ProcessStatus_TerminatedNormally,
                mgr.constants.ProcessStatus_TerminatedSignal,
                mgr.constants.ProcessStatus_TerminatedAbnormally,
                mgr.constants.ProcessStatus_TimedOutKilled,
                mgr.constants.ProcessStatus_TimedOutAbnormally,
                mgr.constants.ProcessStatus_Error,
            ]:
                print(f"Current process status: {process.status}. Waiting...")
                time.sleep(1)

                # Capture and print process output (stdout)
                try:
                    print("Attempting to read stdout...")
                    stdout = b""  # Initialize stdout buffer
                    while True:
                        chunk = process.read(0, 8192, 200)  # Adjusted buffer size
                        if not chunk:
                            break
                        stdout += chunk
                    if stdout:
                        print("Execution Output:")
                        print(stdout.decode('utf-8', 'ignore'))  # Decode and print as UTF-8 with 'ignore'
                    else:
                        print("No stdout output.")
                except Exception as e:
                    print(f"Error reading stdout: {e}")

                # Similarly capture stderr
                try:
                    print("Attempting to read stderr...")
                    stderr = b""  # Initialize stderr buffer
                    while True:
                        chunk = process.read(1, 8192, 200)  # Adjusted buffer size
                        if not chunk:
                            break
                        stderr += chunk
                    if stderr:
                        print("Execution Errors:")
                        print(stderr.decode('utf-8', 'ignore'))  # Decode and print stderr with 'ignore'
                    else:
                        print("No stderr output.")
                except Exception as e:
                    print(f"Error reading stderr: {e}")

        except Exception as e:
            print(f"Error during process monitoring: {e}")
            traceback.print_exc()

        # After process finishes, check the final status
        if process.status == mgr.constants.ProcessStatus_TerminatedNormally:
            print("Process terminated normally.")
        elif process.status == mgr.constants.ProcessStatus_TerminatedSignal:
            print("Process terminated due to a signal.")
        elif process.status == mgr.constants.ProcessStatus_TerminatedAbnormally:
            print("Process terminated abnormally.")
        elif process.status == mgr.constants.ProcessStatus_TimedOutKilled:
            print("Process was timed out and killed.")
        elif process.status == mgr.constants.ProcessStatus_TimedOutAbnormally:
            print("Process timed out and terminated abnormally.")
        elif process.status == mgr.constants.ProcessStatus_Error:
            print("Process encountered an error.")

    except Exception as e:
        print(f"Failed to initialize VirtualBox or locate machines: {e}")
        traceback.print_exc()

    finally:
        if guest_session_ubuntu:
            guest_session_ubuntu.close()
            print("Guest session closed.")

if __name__ == "__main__":
    main()
