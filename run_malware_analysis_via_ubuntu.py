import traceback
from vboxapi import VirtualBoxManager
import time

def main():
    print("Initializing VirtualBoxManager...")
    mgr = VirtualBoxManager(None, None)
    guest_session_ubuntu = None
    process = None  # Add this line to track the process object

    try:
        # Initialize VirtualBox
        vbox = mgr.getVirtualBox()
        session = mgr.getSessionObject(vbox)
        print("VirtualBox initialized successfully.")

        # Locate the Ubuntu machine
        try:
            ubuntu_machine = vbox.findMachine("ftpserver")
            print("Machine located: ftpserver.")
        except Exception as e:
            print(f"Error locating machine 'ftpserver': {e}")
            return

        # Lock the machine
        try:
            ubuntu_machine.lockMachine(session, mgr.constants.LockType_Shared)
            console = session.console
            print("Machine locked and console acquired.")
        except Exception as e:
            print(f"Error locking the machine: {e}")
            return

        # Create a guest session
        try:
            guest_session_ubuntu = console.guest.createSession("hsbeyti", "phd@2005AOU!", "", "")
            print("Guest session created successfully.")
            time.sleep(2)
        except Exception as e:
            print(f"Error creating guest session: {e}")
            return

        # Process creation
        print("Starting process creation for test.sh script...")
        argument = "/home/hsbeyti/test.sh"
        flags = [
            mgr.constants.ProcessCreateFlag_WaitForStdOut,
            mgr.constants.ProcessCreateFlag_WaitForStdErr,
        ]
        try:
            print("Attempting to create process...")
            process = guest_session_ubuntu.processCreateEx(
                "/bin/bash",  # Use bash to execute shell scripts
                ["bash", argument],  # Pass the script to be executed
                "",  # Current working directory
                [],  # Environment variables
                flags,  # Flags
                120000,  # Timeout in ms
                0,  # Normal priority
                [],  # CPU affinity
            )
            print("Process created successfully.")

        except Exception as e:
            print(f"Error occurred during process creation: {e}")
            traceback.print_exc()

        # Wait for the process to start and then monitor its status until it ends
        try:
            # Wait for the process to start (consider longer time if necessary)
            print("Waiting for process to start...")
            while process.status == mgr.constants.ProcessStatus_Starting:
                time.sleep(1)  # Longer sleep to avoid tight looping

            process_id = process.PID  # Access PID after the process has started
            print(f"Process ID (PID): {process_id}")

            # Now we monitor the process status until it ends
            print("Monitoring process status...")

            # Use wait() to block the script until the process ends
            #process.wait()  # This will block the execution until the process terminates
            process.status == mgr.constants.ProcessStatus_Starting
            # Poll the process status until it terminates
            while process.status not in [
                mgr.constants.ProcessStatus_TerminatedNormally,
                mgr.constants.ProcessStatus_TerminatedSignal,
                mgr.constants.ProcessStatus_TerminatedAbnormally,
                mgr.constants.ProcessStatus_TimedOutKilled,
                mgr.constants.ProcessStatus_TimedOutAbnormally,
                mgr.constants.ProcessStatus_Error,
            ]:
                print(f"Current process status: {process.status}. Waiting...")
                time.sleep(1)
                # Capture and print process output (stdout)
                try:
                    print("Attempting to read stdout...")
                    stdout = b""  # Initialize stdout buffer
                    while True:
                        chunk = process.read(0, 8192, 200)  # Adjusted buffer size
                        if not chunk:
                            break
                        stdout += chunk
                    if stdout:
                        print("Execution Output:")
                        print(stdout.decode('utf-8'))  # Decode and print as UTF-8
                    else:
                        print("No stdout output.")
                except Exception as e:
                    print(f"Error reading stdout: {e}")

                # Similarly capture stderr
                try:
                    print("Attempting to read stderr...")
                    stderr = b""  # Initialize stderr buffer
                    while True:
                        chunk = process.read(1, 8192, 200)  # Adjusted buffer size
                        if not chunk:
                            break
                        stderr += chunk
                    if stderr:
                        print("Execution Errors:")
                        print(stderr.decode('utf-8'))  # Decode and print as UTF-8
                    else:
                        print("No stderr output.")
                except Exception as e:
                    print(f"Error reading stderr: {e}")
                process.status == mgr.constants.ProcessStatus_Starting
                # After process finishes, check the final status
                if process.status == mgr.constants.ProcessStatus_TerminatedNormally:
                    print("Process terminated normally.")
                elif process.status == mgr.constants.ProcessStatus_TerminatedSignal:
                    print("Process terminated due to a signal.")
                elif process.status == mgr.constants.ProcessStatus_TerminatedAbnormally:
                    print("Process terminated abnormally.")
                elif process.status == mgr.constants.ProcessStatus_TimedOutKilled:
                    print("Process was timed out and killed.")
                elif process.status == mgr.constants.ProcessStatus_TimedOutAbnormally:
                    print("Process timed out and terminated abnormally.")
                elif process.status == mgr.constants.ProcessStatus_Error:
                    print("Process encountered an error.")

        except Exception as e:
            print(f"Error during process monitoring: {e}")





    except Exception as e:
        print(f"Failed to initialize VirtualBox or locate machines: {e}")
        traceback.print_exc()

    finally:
        if guest_session_ubuntu:
            guest_session_ubuntu.close()
            print("Guest session closed.")


if __name__ == "__main__":
    main()
