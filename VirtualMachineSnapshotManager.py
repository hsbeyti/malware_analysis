import traceback
from vboxapi import VirtualBoxManager
import time


class VirtualMachineSnapshotManager:
    def __init__(self, vm_name, vm_user, vm_password):
        self.vm_name = vm_name
        self.vm_user = vm_user
        self.vm_password = vm_password
        self.mgr = None
        self.vbox = None
        self.session = None
        self.guest_session = None
        self.console = None
        self.windows_machine = None

    def initialize_virtualbox(self):
        """Initialize VirtualBox Manager and the VM session."""
        try:
            print("Initializing VirtualBoxManager...")
            self.mgr = VirtualBoxManager(None, None)  # Initialize the VirtualBox Manager
            self.vbox = self.mgr.getVirtualBox()  # Get the VirtualBox object
            self.session = self.mgr.getSessionObject(self.vbox)  # Get session object
            print("VirtualBox initialized successfully.")
        except Exception as e:
            print(f"Error initializing VirtualBox: {e}")
            traceback.print_exc()
            return False
        return True

    def locate_machine(self):
        """Locate and lock the VM machine."""
        try:
            self.windows_machine = self.vbox.findMachine(self.vm_name)  # Find the VM
            print(f"Machine located: {self.vm_name}.")
            self.windows_machine.lockMachine(self.session, self.mgr.constants.LockType_Shared)  # Lock the machine
            self.console = self.session.console  # Acquire the console
            print("Machine locked and console acquired.")
        except Exception as e:
            print(f"Error locating or locking machine '{self.vm_name}': {e}")
            traceback.print_exc()
            return False
        return True

    def create_guest_session(self):
        """Create a guest session on the VM."""
        try:
            self.guest_session = self.console.guest.createSession(self.vm_user, self.vm_password, "", "")
            print("Guest session created successfully.")
        except Exception as e:
            print(f"Error creating guest session: {e}")
            traceback.print_exc()
            return False
        return True

    def get_snapshot_by_name_or_uuid(self, snapshot_identifier):
        """Retrieve a snapshot by name or UUID."""
        try:
            # Check if the current snapshot matches the identifier
            current_snapshot = self.windows_machine.currentSnapshot
            if current_snapshot:
                if current_snapshot.id == snapshot_identifier or current_snapshot.name == snapshot_identifier:
                    print(f"Current snapshot with name/UUID x'{current_snapshot.id}' found.")
                    return current_snapshot

            # If current snapshot is not a match, check all snapshots
          #  snapshot_count = self.ubuntu_machine.snapshotCount
          #  for i in range(snapshot_count):
          #      snapshot = self.ubuntu_machine.snapshot(i)
          #      if snapshot.id == snapshot_identifier or snapshot.name == snapshot_identifier:
          #          print(f"Snapshot with name/UUID '{snapshot_identifier}' found.")
          #          return snapshot

          #  print(f"No snapshot found with name/UUID '{snapshot_identifier}'.")
        except Exception as e:
            print(f"Error retrieving snapshot by name or UUIDx: {e}")
            traceback.print_exc()
        return None





    def close_existing_sessions(self):
        try:
            # Attempt to release any existing sessions
            if self.session.state != self.mgr.constants.SessionState_Unlocked:
                self.session.unlockMachine()
                print("Existing session unlocked.")
        except Exception as e:
            print(f"Error closing existing session: {e}")

    def power_off_machine(self):
        """Power off the VirtualBox machine using VirtualBoxManager."""
        try:
            # Ensure any existing sessions are closed
            self.close_existing_sessions()

            # Check the machine state before attempting to power off
            if self.windows_machine.state != self.mgr.constants.MachineState_PoweredOff:
                print("Machine is running. Attempting to power it off...")

                # Attempt to lock the machine with an exclusive lock
                try:
                    self.windows_machine.lockMachine(self.session, self.mgr.constants.LockType_Shared)
                    console = self.session.console
                except AttributeError as e:
                    print(f"Error locking the machine: {e}. Ensure VirtualBox constants are loaded correctly.")
                    return

                # Attempt to power down or shut down the machine
                try:
                    if hasattr(console, 'powerDown'):
                        progress = console.powerDown()
                        progress.waitForCompletion(-1)
                        print("Machine powered off successfully.")
                    elif hasattr(console, 'saveState'):
                        progress = console.saveState()
                        progress.waitForCompletion(-1)
                        print("Machine state saved successfully.")
                    elif hasattr(console, 'powerButton'):
                        console.powerButton()
                        print("Machine is shutting down via power button.")
                    else:
                        print("No valid method to power off the machine is available.")
                except Exception as e:
                    print(f"Error during power-off operation: {e}")
                finally:
                    # Unlock the session to avoid leaving it in a locked state
                    if self.session.state == self.mgr.constants.SessionState_Locked:
                        try:
                            self.session.unlockMachine()
                            print("Session unlocked successfully.")
                        except Exception as unlock_error:
                            print(f"Error unlocking the session: {unlock_error}")
            else:
                print("Machine is already powered off.")
        except Exception as e:
            print(f"Error powering off machine: {e}")



    def delete_snapshot(self, snapshot_identifier):
        try:
            # Ensure the machine is powered off
            self.power_off_machine()

            # Find the snapshot by its name or UUID
            snapshot = self.windows_machine.findSnapshot(snapshot_identifier)
            if snapshot:
                print(f"Deleting snapshot '{snapshot.name}'...")
                progress = self.windows_machine.deleteSnapshot(snapshot.id)
                progress.waitForCompletion(-1)  # Wait for completion
                print(f"Snapshot '{snapshot.name}' deleted successfully.")
            else:
                print(f"Snapshot '{snapshot_identifier}' not found.")
        except Exception as e:
            print(f"Error deleting snapshot {snapshot_identifier}: {e}")





    def create_snapshot(self, snapshot_name, snapshot_description):
        try:
            # Ensure the VM is powered off or in a saved state
            if self.windows_machine.state != self.mgr.constants.MachineState_PoweredOff:
                print("Powering off the machine to create snapshot.")
                self.power_off_machine()  # Ensure the machine is powered off before snapshot creation

            # Now create the snapshot
            progress = self.windows_machine.takeSnapshot(snapshot_name, snapshot_description, False)
            progress.waitForCompletion(-1)  # Wait for completion
            print(f"Snapshot '{snapshot_name}' created successfully.")
        except Exception as e:
            print(f"Error creating snapshot {snapshot_name}: {e}")



    def run_guest_command(self, command):
        """Run a command on the guest VM."""
        try:
            print(f"Running command: {command}")
            process = self.guest_session.processCreateEx(
                "cmd.exe",  # Use cmd.exe to execute commands
                ["cmd.exe", "/c", command],  # Pass the command
                "",  # Current working directory
                [],  # Environment variables
                [
                    self.mgr.constants.ProcessCreateFlag_WaitForStdOut,
                    self.mgr.constants.ProcessCreateFlag_WaitForStdErr,
                ],  # Flags
                120000,  # Timeout in ms
                0,  # Normal priority
                [],  # CPU affinity
            )
            # Monitor process status until it terminates
            while process.status == self.mgr.constants.ProcessStatus_Starting:
                time.sleep(1)
            print(f"Process ID: {process.PID}")

            while process.status not in [
                self.mgr.constants.ProcessStatus_TerminatedNormally,
                self.mgr.constants.ProcessStatus_TerminatedSignal,
                self.mgr.constants.ProcessStatus_TerminatedAbnormally,
                self.mgr.constants.ProcessStatus_TimedOutKilled,
                self.mgr.constants.ProcessStatus_TimedOutAbnormally,
                self.mgr.constants.ProcessStatus_Error,
            ]:
                print(f"Current process status: {process.status}. Waiting...")
                time.sleep(1)

            if process.status == self.mgr.constants.ProcessStatus_TerminatedNormally:
                print("Process terminated normally.")
            elif process.status == self.mgr.constants.ProcessStatus_TerminatedSignal:
                print("Process terminated due to a signal.")
            elif process.status == self.mgr.constants.ProcessStatus_TerminatedAbnormally:
                print("Process terminated abnormally.")
            elif process.status == self.mgr.constants.ProcessStatus_TimedOutKilled:
                print("Process was timed out and killed.")
            elif process.status == self.mgr.constants.ProcessStatus_TimedOutAbnormally:
                print("Process timed out and terminated abnormally.")
            elif process.status == self.mgr.constants.ProcessStatus_Error:
                print("Process encountered an error.")
        except Exception as e:
            print(f"Error running guest command: {e}")
            traceback.print_exc()

    def close_session(self):
        """Closes the session."""
        print("Session does not require explicit closing.")
        # No need to explicitly close the session since VirtualBox manages it.


# Example Usage
if __name__ == "__main__":
    vm_manager = VirtualMachineSnapshotManager("malware_analysis", "hsbeyti", "12345678")
    if vm_manager.initialize_virtualbox():  # Initialize VirtualBox
        if vm_manager.locate_machine():  # Locate and lock the machine
            snapshot_name_to_delete = "run_malware_and_die"

            # Adjusted to use get_snapshot_by_uuid
            snapshot_uuid_to_delete = vm_manager.get_snapshot_by_name_or_uuid(snapshot_name_to_delete)
            print(f"Snapshot '{snapshot_uuid_to_delete.id}'")
            if snapshot_uuid_to_delete:
                vm_manager.delete_snapshot(snapshot_uuid_to_delete)

                # Create a new snapshot after deleting the old one
                snapshot_name = "run_malware_and_die"
                snapshot_description = "Snapshot after malware analysis process"
                vm_manager.create_snapshot(snapshot_name, snapshot_description)

            # Run guest operations (optional)
            #  command = "ping google.com"
            #  vm_manager.run_guest_command(command)

            vm_manager.close_session()  # Close the session
