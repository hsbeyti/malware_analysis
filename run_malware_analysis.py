import traceback
from vboxapi import VirtualBoxManager
import time
import traceback
import os

class VirtualBoxManagerHandler:
    def __init__(self, vm_name, username, password, local_file_path, guest_file_path, script_name):
        self.vm_name = vm_name
        self.username = username
        self.password = password
        self.local_file_path = local_file_path
        self.guest_file_path = guest_file_path
        self.script_name = script_name
        self.mgr = None
        self.vbox = None
        self.session = None
        self.guest_session_ubuntu = None
        self.process = None

    def initialize_virtualbox(self):
        """Initialize VirtualBox Manager and the VM session."""
        try:
            print("Initializing VirtualBoxManager...")
            self.mgr = VirtualBoxManager(None, None)
            self.vbox = self.mgr.getVirtualBox()
            self.session = self.mgr.getSessionObject(self.vbox)
            print("VirtualBox initialized successfully.")
        except Exception as e:
            print(f"Error initializing VirtualBox: {e}")
            traceback.print_exc()
            return False
        return True

    def locate_machine(self):
        """Locate and lock the VM machine."""
        try:
            self.ubuntu_machine = self.vbox.findMachine(self.vm_name)
            print(f"Machine located: {self.vm_name}.")
            self.ubuntu_machine.lockMachine(self.session, self.mgr.constants.LockType_Shared)
            self.console = self.session.console
            print("Machine locked and console acquired.")
        except Exception as e:
            print(f"Error locating or locking machine '{self.vm_name}': {e}")
            traceback.print_exc()
            return False
        return True

    def create_guest_session(self):
        """Create a guest session on the VM."""
        try:
            self.guest_session_ubuntu = self.console.guest.createSession(self.username, self.password, "", "")
            print("Guest session created successfully.")
            time.sleep(2)
        except Exception as e:
            print(f"Error creating guest session: {e}")
            traceback.print_exc()
            return False
        return True





    def copy_file_to_guest(self):
        """Copy a file from the local machine to the guest VM."""
        try:
            # Absolute path for the source file
            source_file = os.path.abspath('./data/test.txt')
            source_file = source_file.replace(os.sep, '/')  # Ensure Unix-style path

            print(f"Copying file {source_file} to VM at {self.guest_file_path}...")

            # Check if source file exists
            if not os.path.exists(source_file):
                raise FileNotFoundError(f"Source file {source_file} not found.")

            # Prepare the parameters for copyToGuest
            sources = [source_file]  # List of source file paths (host)
            filters = ["*"]  # Wildcard to copy all files (if needed)
            flags = ["CopyIntoExisting"]  # Flags for copy behavior
            destination = self.guest_file_path  # Destination path on the guest VM

            # Call copyToGuest
            progress = self.guest_session_ubuntu.copyToGuest(
                sources,
                filters,
                flags,
                destination
            )

            print(f"File {source_file} copied successfully.")

        except Exception as e:
            print(f"Error copying file to guest VM: {e}")
            traceback.print_exc()




    def create_process(self, argument, command_to_run, command_time_out):
        """Create a process to run the script on the VM."""
        flags = [
            self.mgr.constants.ProcessCreateFlag_WaitForStdOut,
            self.mgr.constants.ProcessCreateFlag_WaitForStdErr,
        ]
        try:
            print("Attempting to create process...")
            self.process = self.guest_session_ubuntu.processCreateEx(
                "/bin/bash",  # Use bash to execute shell scripts
                ["bash", argument, command_to_run, command_time_out],  # Pass the script to be executed
                "",  # Current working directory
                [],  # Environment variables
                flags,  # Flags
                120000,  # Timeout in ms
                0,  # Normal priority
                [],  # CPU affinity
            )
            print("Process created successfully.")
        except Exception as e:
            print(f"Error occurred during process creation: {e}")
            traceback.print_exc()

    def monitor_process(self):
        """Monitor the process status until it finishes."""
        try:
            print("Waiting for process to start...")
            while self.process.status == self.mgr.constants.ProcessStatus_Starting:
                time.sleep(2)

            process_id = self.process.PID  # Access PID after the process has started
            print(f"Process ID (PID): {process_id}")

            print("Monitoring process status...")
            while self.process.status not in [
                self.mgr.constants.ProcessStatus_TerminatedNormally,
                self.mgr.constants.ProcessStatus_TerminatedSignal,
                self.mgr.constants.ProcessStatus_TerminatedAbnormally,
                self.mgr.constants.ProcessStatus_TimedOutKilled,
                self.mgr.constants.ProcessStatus_TimedOutAbnormally,
                self.mgr.constants.ProcessStatus_Error,
            ]:
                print(f"Current process status: {self.process.status}. Waiting...")
                time.sleep(1)

                # Capture and print process output (stdout)
                try:
                    print("Attempting to read stdout...")
                    stdout = b""  # Initialize stdout buffer
                    while True:
                        chunk = self.process.read(0, 8192, 200)  # Adjusted buffer size
                        if not chunk:
                            break
                        stdout += chunk
                    if stdout:
                        print("Execution Output:")
                        print(stdout.decode('utf-8', 'ignore'))  # Decode and print as UTF-8 with 'ignore'
                    else:
                        print("No stdout output.")
                except Exception as e:
                    print(f"Error reading stdout: {e}")

                # Similarly capture stderr
                try:
                    print("Attempting to read stderr...")
                    stderr = b""  # Initialize stderr buffer
                    while True:
                        chunk = self.process.read(1, 8192, 200)  # Adjusted buffer size
                        if not chunk:
                            break
                        stderr += chunk
                    if stderr:
                        print("Execution Errors:")
                        print(stderr.decode('utf-8', 'ignore'))  # Decode and print stderr with 'ignore'
                    else:
                        print("No stderr output.")
                except Exception as e:
                    print(f"Error reading stderr: {e}")

        except Exception as e:
               print(f"Error during process monitoring: {e}")
               traceback.print_exc()

    def process_termination_status(self):
        """Check the process final status."""
        if self.process.status == self.mgr.constants.ProcessStatus_TerminatedNormally:
            print("Process terminated normally.")
        elif self.process.status == self.mgr.constants.ProcessStatus_TerminatedSignal:
            print("Process terminated due to a signal.")
        elif self.process.status == self.mgr.constants.ProcessStatus_TerminatedAbnormally:
            print("Process terminated abnormally.")
        elif self.process.status == self.mgr.constants.ProcessStatus_TimedOutKilled:
            print("Process was timed out and killed.")
        elif self.process.status == self.mgr.constants.ProcessStatus_TimedOutAbnormally:
            print("Process timed out and terminated abnormally.")
        elif self.process.status == self.mgr.constants.ProcessStatus_Error:
            print("Process encountered an error.")

    def close_session(self):
        """Close the guest session."""
        if self.guest_session_ubuntu:
            self.guest_session_ubuntu.close()
            print("Guest session closed.")

    def run(self):
        """Main logic to run the steps."""
        if not self.initialize_virtualbox():
            return

        if not self.locate_machine():
            return

        if not self.create_guest_session():
            return

        # Copy the file to the guest VM
        self.copy_file_to_guest()

        # Create and monitor process
        self.create_process("/home/hsbeyti/run_on_windows_via_ssh.sh", "ping", "test.txt")
        self.monitor_process()
        self.process_termination_status()
        self.close_session()


if __name__ == "__main__":
    vm_name = "ftpserver"
    username = "hsbeyti"
    password = "phd@2005AOU!"
    local_file_path = "./data/test.txt"
    guest_file_path = "/home/hsbeyti/analysis/test.txt"
    script_name = "run_on_windows_via_ssh.sh"

    vbox_handler = VirtualBoxManagerHandler(vm_name, username, password, local_file_path, guest_file_path, script_name)
    vbox_handler.run()
