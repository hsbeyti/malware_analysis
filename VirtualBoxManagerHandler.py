import traceback

from dotenv import load_dotenv
from vboxapi import VirtualBoxManager
import time
import traceback
import os

class VirtualBoxManagerHandler:
    def __init__(self):
        # Load environment variables from the .env file
        load_dotenv()

        # Initialize attributes with values from .env file
        self.vm_name = os.getenv('VM_NAME_UBUNTU')
        self.username = os.getenv('USERNAME_VM_UBUNTU')
        self.password = os.getenv('PASSWORD_UBUNTU')
        self.local_file_path = os.getenv('LOCAL_SOURCE_DIR')
        self.guest_file_path = os.getenv('GUEST_DIR')
        self.local_destination_copy_file_path = os.getenv('LOCAL_DEST_DIR')
        self.local_file = os.getenv('LOCAL_FILE')
        self.script_name = os.getenv('SCRIPT_NAME')

        # Other attributes
        self.mgr = None
        self.vbox = None
        self.session = None
        self.guest_session_ubuntu = None
        self.process = None

        # Optional: Debug print to verify values
        print(f"VM Handler initialized with:\n"
              f"VM Name: {self.vm_name}, Username: {self.username}, Password: {self.password}\n"
              f"Source Path: {self.local_file_path}, Guest Path: {self.guest_file_path}\n"
              f"Script: {self.script_name}, Destination Path: {self.local_destination_copy_file_path}, Local File: {self.local_file}")


    def initialize_virtualbox(self):
        """Initialize VirtualBox Manager and the VM session."""
        try:
            print("Initializing VirtualBoxManager...")
            self.mgr = VirtualBoxManager(None, None)
            self.vbox = self.mgr.getVirtualBox()
            self.session = self.mgr.getSessionObject(self.vbox)
            print("VirtualBox initialized successfully.")
        except Exception as e:
            print(f"Error initializing VirtualBox: {e}")
            traceback.print_exc()
            return False
        return True

    def locate_machine(self):
        """Locate and lock the VM machine."""
        try:
            self.ubuntu_machine = self.vbox.findMachine(self.vm_name)
            print(f"Machine located: {self.vm_name}.")
            self.ubuntu_machine.lockMachine(self.session, self.mgr.constants.LockType_Shared)
            self.console = self.session.console
            print("Machine locked and console acquired.")
        except Exception as e:
            print(f"Error locating or locking machine '{self.vm_name}': {e}")
            traceback.print_exc()
            return False
        return True

    def create_guest_session(self):
        """Create a guest session on the VM."""
        try:
            self.guest_session_ubuntu = self.console.guest.createSession(self.username, self.password, "", "")
            print("Guest session created successfully.")
            time.sleep(2)
        except Exception as e:
            print(f"Error creating guest session: {e}")
            traceback.print_exc()
            return False
        return True





    def copy_file_to_guest(self, local_file_name, local_file_path="data/", guest_file_path="/home/hsbeyti/analysis/"):
        """Copy a file from the local machine to the guest VM."""
        try:
            # Construct the full local file path
            source_file = os.path.join(local_file_path, local_file_name)
            source_file = os.path.abspath(source_file).replace(os.sep, '/')  # Ensure Unix-style path

            print(f"Copying file {source_file} to VM at {guest_file_path}...")

            # Check if the source file exists
            if not os.path.exists(source_file):
                raise FileNotFoundError(f"Source file {source_file} not found.")

            # Construct the destination path in the guest
            destination = os.path.join(guest_file_path, local_file_name).replace(os.sep, '/')  # Ensure Unix-style path

            # Prepare the parameters for copyToGuest
            sources = [source_file]  # List of source file paths (host)
            filters = ["*"]  # Wildcard to copy all files (if needed)
            flags = ["CopyIntoExisting"]  # Flags for copy behavior

            # Call copyToGuest
            progress = self.guest_session_ubuntu.copyToGuest(
                sources,
                filters,
                flags,
                destination
            )

            print(f"File {source_file} copied successfully to {destination}.")
        except Exception as e:
            print(f"Error copying file to guest VM: {e}")
            traceback.print_exc()


    def copy_file_from_guest_to_host(self, guest_file_name, local_file_path="data/", guest_file_path="/home/hsbeyti/analysis/"):
        """Copy a file from the guest VM to the local machine."""
        try:
            # Construct the full guest file path
            source_file = os.path.join(guest_file_path, guest_file_name).replace(os.sep, '/')

            # Construct the full destination path on the host
            destination = os.path.join(local_file_path, guest_file_name)
            destination = os.path.abspath(destination).replace(os.sep, '/')  # Ensure Unix-style path

            print(f"Copying file from guest ({source_file}) to host ({destination})...")

            # Ensure the destination directory exists
            if not os.path.exists(local_file_path):
                raise FileNotFoundError(f"Destination directory {local_file_path} does not exist.")

            # Prepare the parameters for copyFromGuest
            sources = [source_file]  # List of source file paths (guest)
            filters = ["*"]  # Wildcard to copy all files
            flags = ["CopyIntoExisting"]  # Flag to copy into existing destination
            destination_path = destination  # Destination on host

            # Call copyFromGuest
            progress = self.guest_session_ubuntu.copyFromGuest(
                sources,
                filters,
                flags,
                destination_path
            )

            # Access the progress attributes (not callable)
            state = progress.state if hasattr(progress, 'state') else 'Unknown'
            percent = progress.percent if hasattr(progress, 'percent') else 'Unknown'
            time.sleep(10)
            # Check progress and output status
            print(f"File {source_file} copied successfully to {destination}.")
            print(f"Progress state: {state}, Progress percent: {percent}")

        except Exception as e:
            print(f"Error copying file from guest VM to host machine: {e}")
            traceback.print_exc()




    def create_process(self, argument, command_to_run, command_time_out):
        """Create a process to run the script on the VM."""
        flags = [
            self.mgr.constants.ProcessCreateFlag_WaitForStdOut,
            self.mgr.constants.ProcessCreateFlag_WaitForStdErr,
        ]
        try:
            print("Attempting to create process...")
            self.process = self.guest_session_ubuntu.processCreateEx(
                "/bin/bash",  # Use bash to execute shell scripts
                ["bash", argument, command_to_run, command_time_out],  # Pass the script to be executed
                "",  # Current working directory
                [],  # Environment variables
                flags,  # Flags
                120000,  # Timeout in ms
                0,  # Normal priority
                [],  # CPU affinity
            )
            print("Process created successfully.")
        except Exception as e:
            print(f"Error occurred during process creation: {e}")
            traceback.print_exc()

    def monitor_process(self):
        """Monitor the process status until it finishes."""
        try:
            print("Waiting for process to start...")
            while self.process.status == self.mgr.constants.ProcessStatus_Starting:
                time.sleep(2)

            process_id = self.process.PID  # Access PID after the process has started
            print(f"Process ID (PID): {process_id}")

            print("Monitoring process status...")
            while self.process.status not in [
                self.mgr.constants.ProcessStatus_TerminatedNormally,
                self.mgr.constants.ProcessStatus_TerminatedSignal,
                self.mgr.constants.ProcessStatus_TerminatedAbnormally,
                self.mgr.constants.ProcessStatus_TimedOutKilled,
                self.mgr.constants.ProcessStatus_TimedOutAbnormally,
                self.mgr.constants.ProcessStatus_Error,
            ]:
                print(f"Current process status: {self.process.status}. Waiting...")
                time.sleep(1)

                # Capture and print process output (stdout)
                try:
                    print("Attempting to read stdout...")
                    stdout = b""  # Initialize stdout buffer
                    while True:
                        chunk = self.process.read(0, 8192, 200)  # Adjusted buffer size
                        if not chunk:
                            break
                        stdout += chunk
                    if stdout:
                        print("Execution Output:")
                        print(stdout.decode('utf-8', 'ignore'))  # Decode and print as UTF-8 with 'ignore'
                    else:
                        print("No stdout output.")
                except Exception as e:
                    print(f"Error reading stdout: {e}")

                # Similarly capture stderr
                try:
                    print("Attempting to read stderr...")
                    stderr = b""  # Initialize stderr buffer
                    while True:
                        chunk = self.process.read(1, 8192, 200)  # Adjusted buffer size
                        if not chunk:
                            break
                        stderr += chunk
                    if stderr:
                        print("Execution Errors:")
                        print(stderr.decode('utf-8', 'ignore'))  # Decode and print stderr with 'ignore'
                    else:
                        print("No stderr output.")
                except Exception as e:
                    print(f"Error reading stderr: {e}")

        except Exception as e:
            print(f"Error during process monitoring: {e}")
            traceback.print_exc()

    def process_termination_status(self):
        """Check the process final status."""
        if self.process.status == self.mgr.constants.ProcessStatus_TerminatedNormally:
            print("Process terminated normally.")
        elif self.process.status == self.mgr.constants.ProcessStatus_TerminatedSignal:
            print("Process terminated due to a signal.")
        elif self.process.status == self.mgr.constants.ProcessStatus_TerminatedAbnormally:
            print("Process terminated abnormally.")
        elif self.process.status == self.mgr.constants.ProcessStatus_TimedOutKilled:
            print("Process was timed out and killed.")
        elif self.process.status == self.mgr.constants.ProcessStatus_TimedOutAbnormally:
            print("Process timed out and terminated abnormally.")
        elif self.process.status == self.mgr.constants.ProcessStatus_Error:
            print("Process encountered an error.")

    def close_session(self):
        """Close the guest session."""
        if self.guest_session_ubuntu:
            self.guest_session_ubuntu.close()
            print("Guest session closed.")

    def run(self, binary_to_instrument):
        """Main logic to run the steps."""
        if not self.initialize_virtualbox():
            return

        if not self.locate_machine():
            return

        if not self.create_guest_session():
            return

        # Copy the file to the guest VM
        self.copy_file_to_guest(binary_to_instrument, self.local_file_path, self.guest_file_path)

        # Use the script name and local file dynamically from environment variables
        script_path = os.path.join(self.guest_file_path, self.script_name)
        output_file = self.local_file  # Assuming `self.local_file` is used as output
        self.create_process(script_path, binary_to_instrument, output_file)

        self.monitor_process()

        self.process_termination_status()

        # Copy the result file from the guest VM to the host
        result_file = binary_to_instrument + ".csv"  # Update if you need this dynamically set
        self.copy_file_from_guest_to_host(result_file, self.local_destination_copy_file_path, self.guest_file_path)

        self.close_session()



if __name__ == "__main__":
    # Load the .env file

    # Create an instance of the handler and execute the run method
    vbox_handler = VirtualBoxManagerHandler()
    vbox_handler.run("systeminfox.exe")