/*
 * Copyright 2002-2019 Intel Corporation.
 * 
 * This software is provided to you as Sample Source Code as defined in the accompanying
 * End User License Agreement for the Intel(R) Software Development Products ("Agreement")
 * section 1.L.
 * 
 * This software and the related documents are provided as is, with no express or implied
 * warranties, other than those that are expressly stated in the License.
 */

/*! @file
 *  This file contains an ISA-portable cache simulator
 *  data cache hierarchies
 */


#include "pin.H"

#include <iostream>
#include <stdio.h>
#include <fstream>
#include <cassert>
#include <time.h>
#include "cache.H"
#include "pin_profile.H"
using std::ostream;
using std::cout;
using std::cerr;
using std::string;
using std::endl;

//added by H. Sheyti
/* ===================================================================== */
/* Global Variables */
/* ===================================================================== */

string finishMessage="Ended Normally";
static UINT32 timeo = 60000;// in ms equals to one minute, default value
 double previousClockSysCall=0.0;
 double previousClockCacheLoad=0.0;
 UINT64 cacheMissLoadCountre=0;
 
 unsigned long syscall_count = 0;
 
 

 std::ostream * StoreSysCallStats= NULL;
  std::ostream * StoreCacheLoadMissStats= NULL;

 std::ostream * debugTrace= NULL;
/* ===================================================================== */
/* Commandline Switches */
/* ===================================================================== */

KNOB<string> KnobOutputFile(KNOB_MODE_WRITEONCE,    "pintool",
    "o", "dcache.out", "specify dcache file name");
KNOB<BOOL>   KnobSysCallTrack(KNOB_MODE_WRITEONCE,    "pintool",
    "tsc", "0", "track all Sys calls and when they occur");	
KNOB<string>   KnobSysCallOutputFile(KNOB_MODE_WRITEONCE,    "pintool",
    "os", "sysCallStats.out", "specify syscall stats file name");
KNOB<UINT32> KnobIntrumentationDuration(KNOB_MODE_WRITEONCE, "pintool",
    "to","0", "time out in mimutes, default 10 minutes");
KNOB<string>   KnobTrackLoadsOutputFile(KNOB_MODE_WRITEONCE,    "pintool",
    "ol", "cacheLoadMisStats.out", "save intreval and timing of load Misses ");	
KNOB<BOOL>   KnobTrackLoads(KNOB_MODE_WRITEONCE,    "pintool",
    "tl", "0", "track individual loads -- increases profiling time");
KNOB<BOOL>   KnobTrackStores(KNOB_MODE_WRITEONCE,   "pintool",
   "ts", "0", "track individual stores -- increases profiling time");
KNOB<UINT32> KnobThresholdHit(KNOB_MODE_WRITEONCE , "pintool",
   "rh", "100", "only report memops with hit count above threshold");
KNOB<UINT32> KnobThresholdMiss(KNOB_MODE_WRITEONCE, "pintool",
   "rm","100", "only report memops with miss count above threshold");
KNOB<UINT32> KnobCacheSize(KNOB_MODE_WRITEONCE, "pintool",
    "c","32", "cache size in kilobytes");
KNOB<UINT32> KnobLineSize(KNOB_MODE_WRITEONCE, "pintool",
    "b","128", "cache block size in bytes");
KNOB<UINT32> KnobAssociativity(KNOB_MODE_WRITEONCE, "pintool",
    "a","8", "cache associativity (1 for direct mapped)");

/* ===================================================================== */

INT32 Usage()
{
    cerr <<
        "This tool represents a cache simulator.\n"
        "\n";

    cerr << KNOB_BASE::StringKnobSummary();

    cerr << endl;

    return -1;
}

/* ===================================================================== */
/* Global Variables */
/* ===================================================================== */

// wrap configuation constants into their own name space to avoid name clashes
namespace DL1
{
    const UINT32 max_sets = KILO; // cacheSize / (lineSize * associativity);
    const UINT32 max_associativity = 256; // associativity;
    const CACHE_ALLOC::STORE_ALLOCATION allocation = CACHE_ALLOC::STORE_ALLOCATE;

    typedef CACHE_ROUND_ROBIN(max_sets, max_associativity, allocation) CACHE;
}

DL1::CACHE* dl1 = NULL;

typedef enum
{
    COUNTER_MISS = 0,
    COUNTER_HIT = 1,
    COUNTER_NUM
} COUNTER;



typedef  COUNTER_ARRAY<UINT64, COUNTER_NUM> COUNTER_HIT_MISS;


// holds the counters with misses and hits
// conceptually this is an array indexed by instruction address
COMPRESSOR_COUNTER<ADDRINT, UINT32, COUNTER_HIT_MISS> profile;

/* ===================================================================== */
void storeCacheMissLoadStats(){
	double CurrentClcok=(double)(clock()*1000)/CLOCKS_PER_SEC;// in ms
	double diff=(CurrentClcok-previousClockCacheLoad);// in ms
     if(diff!=0){
			char buf[500];
			sprintf(buf,"%.4f,%.4f",CurrentClcok,diff);
			*StoreCacheLoadMissStats<<buf<<endl;
	      
	      
	      previousClockCacheLoad=CurrentClcok;
		}

}
VOID LoadMulti(ADDRINT addr, UINT32 size, UINT32 instId)
{
    // first level D-cache
    const BOOL dl1Hit = dl1->Access(addr, size, CACHE_BASE::ACCESS_TYPE_LOAD);

    const COUNTER counter = dl1Hit ? COUNTER_HIT : COUNTER_MISS;
    profile[instId][counter]++;
	if(counter==0){
	cacheMissLoadCountre++;
	storeCacheMissLoadStats();
	}
	//*debugTrace<<"Load Mulit"<<endl;
	
}

/* ===================================================================== */

VOID StoreMulti(ADDRINT addr, UINT32 size, UINT32 instId)
{
    // first level D-cache
    const BOOL dl1Hit = dl1->Access(addr, size, CACHE_BASE::ACCESS_TYPE_STORE);

    const COUNTER counter = dl1Hit ? COUNTER_HIT : COUNTER_MISS;
    profile[instId][counter]++;
}

/* ===================================================================== */

VOID LoadSingle(ADDRINT addr, UINT32 instId)
{
    // @todo we may access several cache lines for 
    // first level D-cache
    const BOOL dl1Hit = dl1->AccessSingleLine(addr, CACHE_BASE::ACCESS_TYPE_LOAD);

    const COUNTER counter = dl1Hit ? COUNTER_HIT : COUNTER_MISS;
    profile[instId][counter]++;
	if(counter==0){
	cacheMissLoadCountre++;
	storeCacheMissLoadStats();
	}
}
/* ===================================================================== */

VOID StoreSingle(ADDRINT addr, UINT32 instId)
{
    // @todo we may access several cache lines for 
    // first level D-cache
    const BOOL dl1Hit = dl1->AccessSingleLine(addr, CACHE_BASE::ACCESS_TYPE_STORE);
	
    const COUNTER counter = dl1Hit ? COUNTER_HIT : COUNTER_MISS;
    profile[instId][counter]++;
	
}

/* ===================================================================== */

VOID LoadMultiFast(ADDRINT addr, UINT32 size)
{
    dl1->Access(addr, size, CACHE_BASE::ACCESS_TYPE_LOAD);
}

/* ===================================================================== */

VOID StoreMultiFast(ADDRINT addr, UINT32 size)
{
    dl1->Access(addr, size, CACHE_BASE::ACCESS_TYPE_STORE);
}

/* ===================================================================== */

VOID LoadSingleFast(ADDRINT addr)
{
    dl1->AccessSingleLine(addr, CACHE_BASE::ACCESS_TYPE_LOAD);    
}

/* ===================================================================== */

VOID StoreSingleFast(ADDRINT addr)
{
    dl1->AccessSingleLine(addr, CACHE_BASE::ACCESS_TYPE_STORE);    
}



/* ===================================================================== */

VOID Instruction(INS ins, void * v)
{
    UINT32 memOperands = INS_MemoryOperandCount(ins);
	//fprintf(tracem,"3\n");

    // Instrument each memory operand. If the operand is both read and written
    // it will be processed twice.
    // Iterating over memory operands ensures that instructions on IA-32 with
    // two read operands (such as SCAS and CMPS) are correctly handled.
    for (UINT32 memOp = 0; memOp < memOperands; memOp++)
    {
        const UINT32 size = INS_MemoryOperandSize(ins, memOp);
        const BOOL   single = (size <= 4);
        
        if (INS_MemoryOperandIsRead(ins, memOp))
        {
            if( KnobTrackLoads )
            {
                // map sparse INS addresses to dense IDs
                const ADDRINT iaddr = INS_Address(ins);
                const UINT32 instId = profile.Map(iaddr);

                if( single )
                {
                    INS_InsertPredicatedCall(
                        ins, IPOINT_BEFORE, (AFUNPTR) LoadSingle,
                        IARG_MEMORYOP_EA, memOp,
                        IARG_UINT32, instId,
                        IARG_END);
                }
                else
                {
                    INS_InsertPredicatedCall(
                        ins, IPOINT_BEFORE,  (AFUNPTR) LoadMulti,
                        IARG_MEMORYOP_EA, memOp,
                        IARG_UINT32, size,
                        IARG_UINT32, instId,
                        IARG_END);
                }
            }
            else
            {
                if( single )
                {
                    INS_InsertPredicatedCall(
                        ins, IPOINT_BEFORE,  (AFUNPTR) LoadSingleFast,
                        IARG_MEMORYOP_EA, memOp,
                        IARG_END);
                        
                }
                else
                {
                    INS_InsertPredicatedCall(
                        ins, IPOINT_BEFORE,  (AFUNPTR) LoadMultiFast,
                        IARG_MEMORYOP_EA, memOp,
                        IARG_UINT32, size,
                        IARG_END);
                }
            }
        }
        
        if (INS_MemoryOperandIsWritten(ins, memOp))
        {
            if( KnobTrackStores )
            {
                const ADDRINT iaddr = INS_Address(ins);
                const UINT32 instId = profile.Map(iaddr);

                if( single )
                {
                    INS_InsertPredicatedCall(
                        ins, IPOINT_BEFORE,  (AFUNPTR) StoreSingle,
                        IARG_MEMORYOP_EA, memOp,
                        IARG_UINT32, instId,
                        IARG_END);
                }
                else
                {
                    INS_InsertPredicatedCall(
                        ins, IPOINT_BEFORE,  (AFUNPTR) StoreMulti,
                        IARG_MEMORYOP_EA,memOp,
                        IARG_UINT32, size,
                        IARG_UINT32, instId,
                        IARG_END);
                }
            }
            else
            {
                if( single )
                {
                    INS_InsertPredicatedCall(
                        ins, IPOINT_BEFORE,  (AFUNPTR) StoreSingleFast,
                        IARG_MEMORYOP_EA, memOp,
                        IARG_END);
                        
                }
                else
                {
                    INS_InsertPredicatedCall(
                        ins, IPOINT_BEFORE,  (AFUNPTR) StoreMultiFast,
                        IARG_MEMORYOP_EA, memOp,
                        IARG_UINT32, size,
                        IARG_END);
                }
            }
        }
    }
}

/* ===================================================================== */
//added by H. Sheyti
void savetoFile(){
	std::ofstream out(KnobOutputFile.Value().c_str());
	char buf[100];
    // print D-cache profile
    // @todo what does this print
    out<<finishMessage<< "\n";
    out << "PIN:MEMLATENCIES 1.0. 0x0\n";
            
    out <<
        "#\n"
        "# DCACHE stats\n"
        "#\n";
    
    out << dl1->StatsLong("# ", CACHE_BASE::CACHE_TYPE_DCACHE);

    if( KnobTrackLoads || KnobTrackStores ) {
        out <<
            "#\n"
            "# LOAD stats\n"
            "#\n";
        
        out << profile.StringLong();
    }
    out.close();
   //sprintf(buf,"%d",timeOut)

   //*StoreSysCallStats<<timeOut<<endl;
   if (StoreSysCallStats != &cout) delete StoreSysCallStats;

	*debugTrace<<cacheMissLoadCountre<<endl;
	*debugTrace<<"End"<<endl;
	delete debugTrace;
	*StoreCacheLoadMissStats<<endl;
	if (StoreCacheLoadMissStats != &cout) delete StoreCacheLoadMissStats;
}
VOID Fini(int code, VOID * v)
{

 savetoFile(); //save stats   
}
//added by H. Sheyti
VOID TimeOutThread(VOID* v)
{
	  PIN_Sleep(timeo);// let the thread sleep
	 //finishMessage="Forced by timeout";//
	 //*debugTrace<<"Forced to end"<<timeOut<<endl;
	 PIN_ExitApplication(0);// time is out, finish this intrumentation
}

//added by H. Sheyti
VOID log_syscall(THREADID tid, CONTEXT *ctxt, SYSCALL_STANDARD std, VOID *v)
{
  //syscalls[PIN_GetSyscallNumber(ctxt, std)]++;
	    
		
		double CurrentClcok=(double)(clock()*1000)/CLOCKS_PER_SEC;// in ms
		double diff=(CurrentClcok-previousClockSysCall);// in ms
		
		if(diff!=0){
			char buf[500];
			sprintf(buf,"%ld,%ld,%.4f,%.4f",PIN_GetSyscallNumber(ctxt,std),tid,CurrentClcok,diff);
			*StoreSysCallStats<<buf<<endl;
	      //fprintf(StoreSysCallStats," %ld,%.4f,",PIN_GetSyscallNumber(ctxt,std),CurrentClcok);	
	      //fprintf(StoreSysCallStats,"%.4f\n",diff);
	      
	      previousClockSysCall=CurrentClcok;
		}
  syscall_count++;
}
static void AbortProcess(const string& msg, unsigned long code)
{
    cerr << "Test aborted: " << msg << " with code " << code << endl;
    PIN_WriteErrorMessage(msg.c_str(), 1002, PIN_ERR_FATAL, 0);
}

/* ===================================================================== */

int main(int argc, char *argv[])
{
    PIN_THREAD_UID  tID;
	
	PIN_InitSymbols();


    if( PIN_Init(argc,argv) )
    {
        return Usage();
    }
	//added by H. Sbeyti
	// time out
	if(KnobIntrumentationDuration){
	   timeo=KnobIntrumentationDuration.Value();
	   timeo*=1000;//convert minutes into ms
	   THREADID intThreadId = PIN_SpawnInternalThread(TimeOutThread, NULL, 0, &tID);
          if (intThreadId == INVALID_THREADID)
          {
              AbortProcess("PIN_SpawnInternalThread(intThread) failed", 0);
          }
	}
	 //--time out

	//added by H. Sbeyti
	//sys call
	debugTrace=new std::ofstream("DebugTrace.out");
    if(KnobSysCallTrack){// collect syscalls stats 
      StoreSysCallStats = KnobSysCallOutputFile.Value().empty() ? &cout : new std::ofstream(KnobSysCallOutputFile.Value().c_str(),std::ios_base::app);
	    
		char buf[100];
		sprintf(buf,"%s,%s,%s,%s","SysID","Thread ID","time","inetrval");
		*StoreSysCallStats<<buf<<endl;
		//*StoreSysCallStats<<timeo<<" timeout"<<endl;
	    PIN_AddSyscallEntryFunction(log_syscall, NULL);
	}//-- sys call
	//added by H. Sbeyti
	// load miss
	if(KnobTrackLoads){// collect cache load misses stats 
      StoreCacheLoadMissStats = KnobTrackLoadsOutputFile.Value().empty() ? &cout : new std::ofstream(KnobTrackLoadsOutputFile.Value().c_str(),std::ios_base::app);
	    
		char buf[100];
		sprintf(buf,"%s,%s","time","inetrval");
		*StoreCacheLoadMissStats<<buf<<endl;
		
	    
	}
	// -- load miss
	// end added
	
	//--cache
    dl1 = new DL1::CACHE("L1 Data Cache", 
                         KnobCacheSize.Value() * KILO,
                         KnobLineSize.Value(),
                         KnobAssociativity.Value());
    
    profile.SetKeyName("iaddr          ");
    profile.SetCounterName("dcache:miss        dcache:hit");

    COUNTER_HIT_MISS threshold;

    threshold[COUNTER_HIT] = KnobThresholdHit.Value();
    threshold[COUNTER_MISS] = KnobThresholdMiss.Value();
    profile.SetThreshold( threshold );
	INS_AddInstrumentFunction(Instruction, 0);
	 //--chache
  
    PIN_AddFiniFunction(Fini, 0);
	
    // Never returns
	
    PIN_StartProgram();
    
    return 0;
}

/* ===================================================================== */
/* eof */
/* ===================================================================== */
